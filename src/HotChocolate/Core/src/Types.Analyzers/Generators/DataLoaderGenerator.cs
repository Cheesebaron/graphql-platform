using System.Collections.Immutable;
using System.Text;
using HotChocolate.Types.Analyzers.Helpers;
using HotChocolate.Types.Analyzers.Inspectors;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using static System.StringComparison;
using static HotChocolate.Types.Analyzers.Properties.SourceGenResources;
using static HotChocolate.Types.Analyzers.StringConstants;
using static HotChocolate.Types.Analyzers.WellKnownTypes;

namespace HotChocolate.Types.Analyzers.Generators;

public class DataLoaderGenerator : ISyntaxGenerator
{
    private static readonly DiagnosticDescriptor _keyParameterMissing =
        new(
            id: "HC0074",
            title: "Parameter Missing.",
            messageFormat:
            DataLoader_KeyParameterMissing,
            category: "DataLoader",
            DiagnosticSeverity.Error,
            isEnabledByDefault: true);

    private static readonly DiagnosticDescriptor _methodAccessModifierInvalid =
        new(
            id: "HC0075",
            title: "Access Modifier Invalid.",
            messageFormat:
            DataLoader_InvalidAccessModifier,
            category: "DataLoader",
            DiagnosticSeverity.Error,
            isEnabledByDefault: true);

    public void Initialize(IncrementalGeneratorPostInitializationContext context) { }

    public bool Consume(ISyntaxInfo syntaxInfo)
        => syntaxInfo is DataLoaderInfo or ModuleInfo or DataLoaderDefaultsInfo;

    public void Generate(
        SourceProductionContext context,
        Compilation compilation,
        ReadOnlySpan<ISyntaxInfo> syntaxInfos)
    {
        var (module, defaults) = syntaxInfos.GetDataLoaderDefaults(compilation.AssemblyName);

        var dataLoaders = new List<DataLoaderInfo>();
        var sourceText = StringBuilderPool.Get();

        sourceText.AppendLine("// <auto-generated/>");
        sourceText.AppendLine("#nullable enable");
        sourceText.AppendLine("using System;");
        sourceText.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sourceText.AppendLine("using HotChocolate.Execution.Configuration;");

        foreach (var syntaxInfo in syntaxInfos)
        {
            if (syntaxInfo is not DataLoaderInfo dataLoader)
            {
                continue;
            }

            if (dataLoader.MethodSymbol.Parameters.Length == 0)
            {
                context.ReportDiagnostic(
                    Diagnostic.Create(
                        _keyParameterMissing,
                        Location.Create(
                            dataLoader.MethodSyntax.SyntaxTree,
                            dataLoader.MethodSyntax.ParameterList.Span)));
                continue;
            }

            if (dataLoader.MethodSymbol.DeclaredAccessibility is not Accessibility.Public
                and not Accessibility.Internal and not Accessibility.ProtectedAndInternal)
            {
                context.ReportDiagnostic(
                    Diagnostic.Create(
                        _methodAccessModifierInvalid,
                        Location.Create(
                            dataLoader.MethodSyntax.SyntaxTree,
                            dataLoader.MethodSyntax.Modifiers.Span)));
                continue;
            }

            var keyArg = dataLoader.MethodSymbol.Parameters[0];
            var keyType = keyArg.Type;
            var cancellationTokenIndex = -1;
            var serviceMap = new Dictionary<int, string>();

            if (IsKeysArgument(keyType))
            {
                keyType = ExtractKeyType(keyType);
            }

            InspectDataLoaderParameters(
                dataLoader,
                ref cancellationTokenIndex,
                serviceMap);

            DataLoaderKind kind;

            if (IsReturnTypeDictionary(dataLoader.MethodSymbol.ReturnType, keyType))
            {
                kind = DataLoaderKind.Batch;
            }
            else if (IsReturnTypeLookup(dataLoader.MethodSymbol.ReturnType, keyType))
            {
                kind = DataLoaderKind.Group;
            }
            else
            {
                keyType = keyArg.Type;
                kind = DataLoaderKind.Cache;
            }

            var valueType = ExtractValueType(dataLoader.MethodSymbol.ReturnType, kind);

            dataLoaders.Add(dataLoader);

            GenerateDataLoader(
                dataLoader,
                defaults,
                kind,
                keyType,
                valueType,
                dataLoader.MethodSymbol.Parameters.Length,
                cancellationTokenIndex,
                serviceMap);
        }

        // if we find no valid DataLoader we will not create any file.
        if (dataLoaders.Count > 0)
        {
            if (defaults.RegisterServices)
            {
                // write DI integration
                sourceText.AppendLine();
                sourceText.AppendLine("namespace Microsoft.Extensions.DependencyInjection");
                sourceText.AppendLine("{");
                GenerateDataLoaderRegistrations(module, dataLoaders, sourceText);
                sourceText.AppendLine("}");
            }

            context.AddSource(
                WellKnownFileNames.DataLoaderFile,
                SourceText.From(sourceText.ToString(), Encoding.UTF8));
        }

        StringBuilderPool.Return(sourceText);
    }

    private static void GenerateDataLoader(
        DataLoaderInfo dataLoader,
        DataLoaderDefaultsInfo defaults,
        DataLoaderKind kind,
        ITypeSymbol keyType,
        ITypeSymbol valueType,
        int parameterCount,
        int cancelIndex,
        Dictionary<int, string> services)
    {
        var isScoped = dataLoader.IsScoped ?? defaults.Scoped ?? false;
        var isPublic = dataLoader.IsPublic ?? defaults.IsPublic ?? true;
        var isInterfacePublic = dataLoader.IsInterfacePublic ?? defaults.IsInterfacePublic ?? true;

        var generator = new DataLoaderSyntaxGenerator();

        generator.WriterHeader();
        generator.WriteBeginNamespace(dataLoader.Namespace);

        generator.WriteDataLoaderInterface(dataLoader.InterfaceName, isInterfacePublic, kind, keyType, valueType);

        generator.WriteBeginDataLoaderClass(
            dataLoader.Name,
            dataLoader.InterfaceName,
            isPublic,
            kind,
            keyType,
            valueType);
        generator.WriteDataLoaderConstructor(dataLoader.Name, kind);
        generator.WriteDataLoaderLoadMethod(
            dataLoader.ContainingType,
            dataLoader.MethodName,
            isScoped,
            kind,
            keyType,
            valueType,
            services,
            parameterCount,
            cancelIndex);
        generator.WriteEndDataLoaderClass();

        generator.WriteEndNamespace();
    }

    private static void GenerateDataLoaderRegistrations(
        ModuleInfo module,
        List<DataLoaderInfo> dataLoaders,
        StringBuilder sourceText)
    {
        sourceText.Append(Indent)
            .Append("public static partial class ")
            .Append(module.ModuleName)
            .AppendLine("RequestExecutorBuilderExtensions");

        sourceText
            .Append(Indent)
            .AppendLine("{");

        sourceText
            .Append(Indent)
            .Append(Indent)
            .Append("static partial void RegisterGeneratedDataLoader(")
            .AppendLine("IRequestExecutorBuilder builder)");

        sourceText
            .Append(Indent)
            .Append(Indent)
            .AppendLine("{");

        foreach (var dataLoader in dataLoaders)
        {
            sourceText
                .Append(Indent)
                .Append(Indent)
                .Append(Indent)
                .Append("builder.AddDataLoader<")
                .Append(dataLoader.InterfaceFullName)
                .Append(", ")
                .Append(dataLoader.FullName)
                .AppendLine(">();");
        }

        sourceText
            .Append(Indent)
            .Append(Indent)
            .AppendLine("}");

        sourceText
            .Append(Indent)
            .AppendLine("}");
    }

    private static void InspectDataLoaderParameters(
        DataLoaderInfo dataLoader,
        ref int cancellationTokenIndex,
        Dictionary<int, string> serviceMap)
    {
        for (var i = 1; i < dataLoader.MethodSymbol.Parameters.Length; i++)
        {
            var argument = dataLoader.MethodSymbol.Parameters[i];
            var argumentType = argument.Type.ToFullyQualified();

            if (IsCancellationToken(argumentType))
            {
                if (cancellationTokenIndex != -1)
                {
                    // report error
                    return;
                }

                cancellationTokenIndex = i;
            }
            else
            {
                serviceMap[i] = argumentType;
            }
        }
    }

    private static bool IsKeysArgument(ITypeSymbol type)
        => type is INamedTypeSymbol { IsGenericType: true, TypeArguments.Length: 1, } nt &&
            ReadOnlyList.Equals(ToTypeNameNoGenerics(nt), Ordinal);

    private static ITypeSymbol ExtractKeyType(ITypeSymbol type)
    {
        if (type is INamedTypeSymbol { IsGenericType: true, TypeArguments.Length: 1, } namedType &&
            ReadOnlyList.Equals(ToTypeNameNoGenerics(namedType), Ordinal))
        {
            return namedType.TypeArguments[0];
        }

        throw new InvalidOperationException();
    }

    private static bool IsCancellationToken(string typeName)
        => string.Equals(typeName, WellKnownTypes.CancellationToken) ||
            string.Equals(typeName, GlobalCancellationToken);

    private static bool IsReturnTypeDictionary(ITypeSymbol returnType, ITypeSymbol keyType)
    {
        if (returnType is INamedTypeSymbol { TypeArguments.Length: 1, } namedType)
        {
            var resultType = namedType.TypeArguments[0];

            if (IsReadOnlyDictionary(resultType) &&
                resultType is INamedTypeSymbol { TypeArguments.Length: 2, } dictionaryType &&
                dictionaryType.TypeArguments[0].Equals(keyType, SymbolEqualityComparer.Default))
            {
                return true;
            }
        }
        
        return false;
    }

    private static bool IsReturnTypeLookup(ITypeSymbol returnType, ITypeSymbol keyType)
    {
        if (returnType is INamedTypeSymbol { TypeArguments.Length: 1, } namedType)
        {
            var resultType = namedType.TypeArguments[0];

            if (ToTypeNameNoGenerics(resultType).Equals(Lookup, Ordinal) &&
                resultType is INamedTypeSymbol { TypeArguments.Length: 2, } dictionaryType &&
                dictionaryType.TypeArguments[0].Equals(keyType, SymbolEqualityComparer.Default))
            {
                return true;
            }
        }
        return false;
    }

    private static bool IsReadOnlyDictionary(ITypeSymbol type)
    {
        if (!ToTypeNameNoGenerics(type).Equals(ReadOnlyDictionary, Ordinal))
        {
            foreach (var interfaceSymbol in type.Interfaces)
            {
                if (ToTypeNameNoGenerics(interfaceSymbol).Equals(ReadOnlyDictionary, Ordinal))
                {
                    return true;
                }
            }

            return false;
        }

        return true;
    }

    private static ITypeSymbol ExtractValueType(ITypeSymbol returnType, DataLoaderKind kind)
    {
        if (returnType is INamedTypeSymbol { TypeArguments.Length: 1, } namedType)
        {
            if (kind is DataLoaderKind.Batch or DataLoaderKind.Group &&
                namedType.TypeArguments[0] is INamedTypeSymbol { TypeArguments.Length: 2, } dict)
            {
                return dict.TypeArguments[1];
            }

            if (kind is DataLoaderKind.Cache)
            {
                return namedType.TypeArguments[0];
            }
        }

        throw new InvalidOperationException();
    }

    private static string ToTypeNameNoGenerics(ITypeSymbol typeSymbol)
        => $"{typeSymbol.ContainingNamespace}.{typeSymbol.Name}";
}

internal static class GeneratorUtils
{
    public static ModuleInfo GetModuleInfo(
        this ImmutableArray<ISyntaxInfo> syntaxInfos,
        string? assemblyName,
        out bool defaultModule)
    {
        foreach (var syntaxInfo in syntaxInfos)
        {
            if (syntaxInfo is ModuleInfo module)
            {
                defaultModule = false;
                return module;
            }
        }

        defaultModule = true;
        return new ModuleInfo(CreateModuleName(assemblyName), ModuleOptions.Default);
    }

    public static (ModuleInfo, DataLoaderDefaultsInfo) GetDataLoaderDefaults(
        this ReadOnlySpan<ISyntaxInfo> syntaxInfos,
        string? assemblyName)
    {
        ModuleInfo? moduleInfo = null;
        DataLoaderDefaultsInfo? dataLoaderDefaultsInfo = null;

        foreach (var syntaxInfo in syntaxInfos)
        {
            if (moduleInfo is null && syntaxInfo is ModuleInfo mi)
            {
                moduleInfo = mi;
            }
            else if (dataLoaderDefaultsInfo is null && syntaxInfo is DataLoaderDefaultsInfo dldi)
            {
                dataLoaderDefaultsInfo = dldi;
            }

            if (moduleInfo is not null && dataLoaderDefaultsInfo is not null)
            {
                return (moduleInfo, dataLoaderDefaultsInfo);
            }
        }

        moduleInfo ??= new ModuleInfo(CreateModuleName(assemblyName), ModuleOptions.Default);
        dataLoaderDefaultsInfo ??= new DataLoaderDefaultsInfo(null, null, true, true);

        return (moduleInfo, dataLoaderDefaultsInfo);
    }

    private static string CreateModuleName(string? assemblyName)
        => assemblyName is null
            ? "AssemblyTypes"
            : assemblyName.Split('.').Last() + "Types";
}

public sealed class DataLoaderSyntaxGenerator
{
    private StringBuilder _sb;
    private CodeWriter _writer;
    private bool _disposed;

    public DataLoaderSyntaxGenerator()
    {
        _sb = StringBuilderPool.Get();
        _writer = new CodeWriter(_sb);
    }

    public void WriterHeader()
    {
        _writer.WriteFileHeader();
        _writer.WriteIndentedLine("using Microsoft.Extensions.DependencyInjection;");
    }

    public void WriteBeginNamespace(string ns)
    {
        _writer.WriteIndentedLine("namespace {0}", ns);
        _writer.WriteIndentedLine("{");
        _writer.IncreaseIndent();
    }

    public void WriteEndNamespace()
    {
        _writer.DecreaseIndent();
        _writer.WriteIndentedLine("}");
    }

    public void WriteDataLoaderInterface(
        string name,
        bool isPublic,
        DataLoaderKind kind,
        ITypeSymbol key,
        ITypeSymbol value)
    {
        _writer.WriteIndentedLine(
            "{0} interface {1}",
            isPublic
                ? "public"
                : "internal",
            name);
        _writer.IncreaseIndent();

        if (kind is DataLoaderKind.Group)
        {
            _writer.WriteIndentedLine(
                ": global::GreenDonut.IDataLoader<{0}, {1}[]>",
                key.ToFullyQualified(),
                value.ToFullyQualified());
        }
        else
        {
            _writer.WriteIndentedLine(
                ": global::GreenDonut.IDataLoader<{0}, {1}>",
                key.ToFullyQualified(),
                value.ToFullyQualified());
        }

        _writer.DecreaseIndent();
        _writer.WriteIndentedLine("{");
        _writer.WriteIndentedLine("}");
    }

    public void WriteBeginDataLoaderClass(
        string name,
        string interfaceName,
        bool isPublic,
        DataLoaderKind kind,
        ITypeSymbol key,
        ITypeSymbol value)
    {
        _writer.WriteIndentedLine(
            "{0} sealed class {1}",
            isPublic
                ? "public"
                : "internal",
            name);
        _writer.IncreaseIndent();

        switch (kind)
        {
            case DataLoaderKind.Batch:
                _writer.WriteIndentedLine(
                    ": global::GreenDonut.BatchDataLoader<{0}, {1}[]>",
                    key.ToFullyQualified(),
                    value.ToFullyQualified());
                break;

            case DataLoaderKind.Group:
                _writer.WriteIndentedLine(
                    ": global::GreenDonut.GroupedDataLoader<{0}, {1}>",
                    key.ToFullyQualified(),
                    value.ToFullyQualified());
                break;

            case DataLoaderKind.Cache:
                _writer.WriteIndentedLine(
                    ": global::GreenDonut.CacheDataLoader<{0}, {1}>",
                    key.ToFullyQualified(),
                    value.ToFullyQualified());
                break;
        }

        _writer.WriteIndentedLine(", {0}", interfaceName);
        _writer.DecreaseIndent();
        _writer.WriteIndentedLine("{");
    }

    public void WriteEndDataLoaderClass()
    {
        _writer.DecreaseIndent();
        _writer.WriteIndentedLine("}");
    }

    public void WriteDataLoaderConstructor(
        string name,
        DataLoaderKind kind)
    {
        _writer.WriteIndentedLine("private readonly global::System.IServiceProvider _services;");
        _writer.WriteLine();

        if (kind is DataLoaderKind.Batch or DataLoaderKind.Group)
        {
            _writer.WriteIndentedLine("public {0}(", name);

            using (_writer.IncreaseIndent())
            {
                _writer.WriteIndentedLine("global::System.IServiceProvider services,");
                _writer.WriteIndentedLine("global::GreenDonut.IBatchScheduler batchScheduler,");
                _writer.WriteIndentedLine("global::GreenDonut.DataLoaderOptions? options = null)");
                _writer.WriteIndentedLine(": base(batchScheduler, options)");
            }
        }
        else
        {
            _writer.WriteIndentedLine("public {0}(", name);

            using (_writer.IncreaseIndent())
            {
                _writer.WriteIndentedLine("global::System.IServiceProvider services,");
                _writer.WriteIndentedLine("global::GreenDonut.DataLoaderOptions? options = null)");
                _writer.WriteIndentedLine(": base(options)");
            }
        }

        _writer.WriteIndentedLine("{");

        using (_writer.IncreaseIndent())
        {
            _writer.WriteIndentedLine("_services = services ?? System.ArgumentNullException(nameof(services));");
        }

        _writer.WriteIndentedLine("}");
        _writer.WriteLine();
    }

    public void WriteDataLoaderLoadMethod(
        string containingType,
        string methodName,
        bool isScoped,
        DataLoaderKind kind,
        ITypeSymbol key,
        ITypeSymbol value,
        Dictionary<int, string> services,
        int parameterCount,
        int cancelIndex)
    {
        if (kind is DataLoaderKind.Batch)
        {
            _writer.WriteIndentedLine(
                "protected override async global::{0}<{1}<{2}, {3}>> LoadBatchAsync(",
                WellKnownTypes.Task,
                ReadOnlyDictionary,
                key.ToFullyQualified(),
                value.ToFullyQualified());

            using (_writer.IncreaseIndent())
            {
                _writer.WriteIndentedLine("{0}<{1}> keys,", ReadOnlyList, key.ToFullyQualified());
                _writer.WriteIndentedLine("global::{0} ct)", WellKnownTypes.CancellationToken);
            }
        }
        else if (kind is DataLoaderKind.Group)
        {
            _writer.WriteIndentedLine(
                "protected override async global::{0}<{1}<{2}, {3}>> LoadGroupedBatchAsync(",
                WellKnownTypes.Task,
                Lookup,
                key.ToFullyQualified(),
                value.ToFullyQualified());

            using (_writer.IncreaseIndent())
            {
                _writer.WriteIndentedLine("{0}<{1}> keys,", ReadOnlyList, key.ToFullyQualified());
                _writer.WriteIndentedLine("global::{0} ct)", WellKnownTypes.CancellationToken);
            }
        }
        else if (kind is DataLoaderKind.Cache)
        {
            _writer.WriteIndentedLine(
                "protected override async global::{0}<{1}> LoadSingleAsync(",
                WellKnownTypes.Task,
                value.ToFullyQualified());

            using (_writer.IncreaseIndent())
            {
                _writer.WriteIndentedLine("{0} keys,", ReadOnlyList, key.ToFullyQualified());
                _writer.WriteIndentedLine("global::{0} ct)", WellKnownTypes.CancellationToken);
            }
        }

        _writer.WriteIndentedLine("{");

        using (_writer.IncreaseIndent())
        {
            if (isScoped)
            {
                _writer.WriteIndentedLine("await using var scope = _services.CreateAsyncScope();");

                foreach (var item in services.OrderBy(t => t.Key))
                {
                    _writer.WriteIndentedLine(
                        "var p{0} = scope.ServiceProvider.GetRequiredService<{1}>();",
                        item.Key,
                        item.Value);
                }
            }
            else
            {
                foreach (var item in services.OrderBy(t => t.Key))
                {
                    _writer.WriteIndentedLine(
                        "var p{0} = _services.GetRequiredService<{1}>();",
                        item.Key,
                        item.Value);
                }
            }

            _writer.WriteIndented("return await {0}.{1}(", containingType, methodName);

            for (var i = 0; i < parameterCount; i++)
            {
                if (i > 0)
                {
                    _writer.Write(", ");
                }

                if (i == 0)
                {
                    _writer.Write(
                        kind is DataLoaderKind.Cache
                            ? "key"
                            : "keys");
                }
                else if (i == cancelIndex)
                {
                    _writer.Write("ct");
                }
                else
                {
                    _writer.Write("p");
                    _writer.Write(i);
                }
            }
            _writer.WriteLine(").ConfigureAwait(false);");
        }

        _writer.WriteIndentedLine("}");
        _writer.WriteIndentedLine("}");
        _writer.WriteIndentedLine("}");
        _writer.WriteLine();
    }

    public override string ToString()
        => _sb.ToString();

    public SourceText ToSourceText()
        => SourceText.From(ToString(), Encoding.UTF8);

    public void Dispose()
    {
        if (_disposed)
        {
            return;
        }

        StringBuilderPool.Return(_sb);
        _sb = default!;
        _writer = default!;
        _disposed = true;
    }
}