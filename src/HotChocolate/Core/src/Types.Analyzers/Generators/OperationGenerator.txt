using System.Text;
using HotChocolate.Types.Analyzers.Helpers;
using HotChocolate.Types.Analyzers.Inspectors;
using Microsoft.CodeAnalysis;
using static HotChocolate.Types.Analyzers.StringConstants;

namespace HotChocolate.Types.Analyzers.Generators;

public class OperationGenerator : ISyntaxGenerator
{
    public void Initialize(IncrementalGeneratorPostInitializationContext context) { }

    public bool Consume(ISyntaxInfo syntaxInfo)
        => syntaxInfo is DataLoaderInfo or ModuleInfo or DataLoaderDefaultsInfo;

    public void Generate(
        SourceProductionContext context, 
        Compilation compilation, 
        ReadOnlySpan<ISyntaxInfo> syntaxInfos)
    {
        var module = syntaxInfos.GetModuleInfo(compilation.AssemblyName, out var defaultModule);

        // if there is only the module info we do not need to generate a module.
        if (!defaultModule && syntaxInfos.Length == 1)
        {
            return;
        }

        var sourceText = StringBuilderPool.Get();
        sourceText.AppendLine("// <auto-generated/>");
        sourceText.AppendLine("#nullable enable");
        sourceText.AppendLine("using System;");
        sourceText.AppendLine("using HotChocolate.Execution.Configuration;");

        sourceText.AppendLine();
        sourceText.AppendLine("namespace Microsoft.Extensions.DependencyInjection");
        sourceText.AppendLine("{");

        sourceText.Append(Indent)
            .Append("public static partial class ")
            .Append(module.ModuleName)
            .AppendLine("RequestExecutorBuilderExtensions");

        sourceText.Append(Indent)
            .AppendLine("{");
        
        
        
        sourceText.Append(Indent)
            .AppendLine("}");
        
        sourceText.AppendLine("}");
        
        throw new NotImplementedException();
    }

    private void Foo(ReadOnlySpan<DataLoaderInfo> operations)
    {
        var sourceText = StringBuilderPool.Get();

        foreach (var operation in operations)
        {
    /*
    public class __Query_1234 : ObjectTypeExtension 
    {
        protected override void Configure(IObjectTypeDescriptor descriptor)
        {
            Type type1 = typeof(Query);
            descriptor.Field(type1.GetMember("GetBook", System.Reflection.BindingFlags.Public)[0]);
        }
    }*/
        }
    }
    // BindingFlags.Static | BindingFlags.Public
}




public static class QueryExtensionGenerator
{
    public static void Write(
        CodeWriter writer,
        string ns,
        string typeName,
        IReadOnlyCollection<OperationInfo> operations)
    {
        writer.WriteIndentedLine("namespace {0}", ns);
        writer.WriteIndentedLine("{");

        WriteType(writer, typeName, operations);
        
        writer.WriteIndentedLine("}");
    }
    
    private static void WriteType(CodeWriter writer, string typeName, IReadOnlyCollection<OperationInfo> operations)
    {
        writer.WriteIndentedLine("public sealed class {0} : ObjectTypeExtension", typeName);
        writer.WriteIndentedLine("{");

        using (writer.IncreaseIndent())
        {
            WriteConfigure(writer, operations);
        }
        
        writer.WriteIndentedLine("}");
    } 
    
    private static void WriteConfigure(CodeWriter writer, IReadOnlyCollection<OperationInfo> operations)
    {
        writer.WriteIndentedLine(
            "protected override void Configure(global::HotChocolate.Types.IObjectTypeDescriptor descriptor)");
        writer.WriteIndentedLine("{");

        using (writer.IncreaseIndent())
        {
            var typeCount = 0;
            foreach (var type in operations.GroupBy(t => t.TypeName))
            {
                var typeVariableName = $"t_{++typeCount}";
                WriteType(writer, typeVariableName, type.Key);

                foreach (var operation in type)
                {
                    WriteRootField(writer, typeVariableName, operation.MethodName);
                }
            }
        }

        writer.WriteIndentedLine("}");
    }
    
    private static void WriteType(CodeWriter writer, string typeVariable, string typeName)
        => writer.WriteIndentedLine("Type {0} = typeof({1});", typeVariable, typeName);

    private static void WriteRootField(CodeWriter writer, string typeVariable, string methodName)
        => writer.WriteIndentedLine(
            "descriptor.Field({0}.GetMember(\"{1}\", " +
            "global::System.Reflection.BindingFlags.Static | " +
            "global::System.Reflection.BindingFlags.Public | " +
            "global::System.Reflection.BindingFlags.NonPublic)[0]);",
            typeVariable,
            methodName);
}

public class OperationInfo
{
    public string TypeName { get; } = default!;
    public string MethodName { get; } = default!;
}